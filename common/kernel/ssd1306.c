/*******
 * I2C asynchronous driver for ssd1306 series 128x64 point displays
 *
 * License: GPLv3
 * Author: Martin K. Schr√∂der
 * Email: info@fortmax.se
 * Website: http://oskit.se
 */

#include <avr/pgmspace.h>
#include <stdlib.h>

#include <kernel/device.h>
#include <kernel/i2c.h>
#include <kernel/ssd1306.h>

#include "../drivers/uart.h"

#include <string.h>

#define DISPLAY_ADDRESS 0x78

#define U8G_ESC_CS(x) 255, (0xd0 | ((x)&0x0f))
#define U8G_ESC_ADR(x) 255, (0xe0 | ((x)&0x0f))
#define U8G_ESC_RST(x) 255, (0xc0 | ((x)&0x0f))
#define U8G_ESC_END 255, 254

struct ssd1306_request {
	struct {
		uint8_t command : 1;
		uint8_t text : 1;
		uint8_t pgmem : 1; 
	} flags; 
	uint8_t *data;
	uint8_t ptr; 
	uint8_t size;
};

// types of requests:
// init: one long command request
// scroll: one small command request
// data: one command, then data request
// text: 
typedef struct ssd1306_device {
	struct {
		uint8_t in_use : 1; 
		uint8_t busy : 1;
	} flags;

	// user callback
	async_callback_t callback;
	void *arg;

	// callbacks used for internal ops
	async_callback_t __callback;
	void *__arg;
	
	uint8_t _commands[40]; // command buffer
	uint8_t _data[64];
	uint8_t _data_size;

	struct ssd1306_request request[4];
	uint8_t request_ptr;
	uint8_t request_size;
	
	uint16_t addr;  // byte address in the display ram
} ssd1306_device_t;

static ssd1306_device_t _device[1];
static handle_t i2c = 0;
static const unsigned char font[];

void ssd1306_get_glyph(uint8_t ch, char *glyph); 

static void __init_display(handle_t dev, async_callback_t cb, void *arg);

handle_t ssd1306_open(id_t id){
	ssd1306_device_t *dev = &_device[0];
	if(dev->flags.in_use) return INVALID_HANDLE;
	dev->flags.in_use = 1;
	dev->flags.busy = 0;
	return dev;
}

int8_t ssd1306_init(handle_t dev, async_callback_t callback, void *ptr){
	__init_display(dev, callback, ptr);
	return SUCCESS; 
}

/// asynchronously sends one command to the display
static void __each_command(void *block, uint8_t *it, uint8_t last, void *arg, void (*callback)(void *block)) {
	ssd1306_device_t *dev = (ssd1306_device_t*)arg;

	static uint8_t buffer[2];

	buffer[0] = 0x00;
	buffer[1] = (*it);

	// send the i2c command to the i2c driver and have it call
	// supplied callback when the transfer is completed
	i2c_command_t cmd = {
		.addr = DISPLAY_ADDRESS,
		.buf = buffer,
		.wcount = 2,
		.rcount = 0,
		.callback = callback,
		.arg = block
	}; 
	i2c_transfer(i2c, cmd);

	// if it is the last byte then call user callback 
	if(last){
		dev->flags.busy = 0;
		// schedule callback for async execution on next tick
		async_schedule(dev->callback, dev->arg, 0); 
	}
	// Aruduino equivalent (blocking)
	//uint8_t control = 0x00;   // Co = 0, D/C = 0
	//Wire.beginTransmission(_i2caddr);
	//Wire.write(control);
	//Wire.write(c);
	//Wire.endTransmission();
}

/// executes a series of commands using async foreach loop
/// one command per main loop tick. 
static void __run_commands(handle_t arg, uint8_t *buffer, uint8_t size, async_callback_t callback, void *cbarg){
	ssd1306_device_t *dev = (ssd1306_device_t*)arg;
	
	memcpy(dev->_commands, buffer, size);
	dev->callback = callback;
	dev->arg = cbarg;
	
	async_schedule_each(dev->_commands, 1, size, __each_command, dev); 
}

static void __each_data(void *block, uint8_t *it, uint8_t last, void *arg, void (*callback)(void *block)){
	ssd1306_device_t *dev = (ssd1306_device_t*)arg;
	
	static uint8_t buffer[2];
	buffer[0] = 0x40;
	buffer[1] = (*it); 
	i2c_transfer(i2c, (i2c_command_t){
		.addr = DISPLAY_ADDRESS,
		.buf = buffer,
		.wcount = 2,
		.rcount = 0,
		.callback = callback,
		.arg = block
	});
	if(last){
		dev->flags.busy = 0;

		// data is always preceded by command sequence to set address
		// so the user callback is placed in __ pointers and ordinary
		// pointers are used for internal callbacks. 
		async_schedule(dev->__callback, dev->__arg, 0); 
	}
}

static void __push_data(handle_t arg, uint8_t *buffer, uint8_t size, async_callback_t callback, void *ptr){
	ssd1306_device_t *dev = (ssd1306_device_t*)arg;
	
	memcpy(dev->_commands, buffer, size);
	dev->callback = callback;
	dev->arg = arg;
	
	async_schedule_each(dev->_commands, 1, size, __each_data, dev); 
}

static void _fill_display_data(void *arg){
	struct ssd1306_device *dev = (ssd1306_device_t*)arg;
	
	__push_data(arg, dev->_data, dev->_data_size, dev->__callback, dev->__arg);
}

static void __process(void *arg) {
	ssd1306_device_t *dev = (ssd1306_device_t*)arg;
	struct ssd1306_request *req = &dev->request[dev->request_ptr];
	
	static uint8_t buffer[2];

	buffer[0] = (req->flags.command)?0x00:0x40;
	if(req->flags.pgmem)
		buffer[1] = pgm_read_byte(&req->data[req->ptr]);
	else if(req->flags.text){
		uint8_t ch = req->data[req->ptr >> 3];
		uint8_t col = (req->ptr & 0x07); 
		const unsigned char *data = &font[ch * 5 + col];
		//req->ptr++;
		if(col >= 5){
			req->ptr &= ~0x07;
			req->ptr += 8;
		}
		buffer[1] = pgm_read_byte(data); 
	} else
		buffer[1] = req->data[req->ptr];

	req->ptr++;
	if(req->ptr >= req->size){
		dev->request_ptr++;
		if(dev->request_ptr >= dev->request_size){
			dev->flags.busy = 0;
			async_schedule(dev->callback, dev->arg, 0);
			return; 
		}
	}
	
	// send the i2c command to the i2c driver and have it call
	// supplied callback when the transfer is completed
	i2c_transfer(i2c, (i2c_command_t){
		.addr = DISPLAY_ADDRESS,
		.buf = buffer,
		.wcount = 2,
		.rcount = 0,
		.callback = __process,
		.arg = dev
	});
}

/// Write raw buffer into the desplay. 
int8_t ssd1306_putstring(handle_t handle, const uint8_t *data, uint8_t size, async_callback_t callback, void *ptr){
	struct ssd1306_device *dev = (ssd1306_device_t*)handle;

	static uint8_t buffer[] = {
		U8G_ESC_ADR(0),           // instruction mode 
		U8G_ESC_CS(1),             // enable chip 
		0x000, //| (col & 0x0f),		// set lower 4 bit of the col adr to 0 
		0x010, // | ((col >> 4) & 0x0f),		// set higher 4 bit of the col adr to 0 
		0x0b0, // | (dev->addr >> 7) & 0x0f,  	// page address
		U8G_ESC_END,                // end of sequence 
	};

	memcpy(dev->_data, data, size);
	
	dev->request[0] = (struct ssd1306_request){
		.data = buffer,
		.flags.text = 0, 
		.flags.command = 1,
		.flags.pgmem = 0, 
		.ptr = 0,
		.size = sizeof(buffer)
	}; 
	dev->request[1] = (struct ssd1306_request){
		.data = dev->_data,
		.flags.text = 1, 
		.flags.command = 0,
		.flags.pgmem = 0, 
		.ptr = 0,
		.size = size * 5
	}; 
	
	dev->request_ptr = 0;
	dev->request_size = 2;
	
	dev->callback = callback;
	dev->arg = ptr;
	
	__process(dev);
	
	// copy the data into the internal buffer
}

int8_t ssd1306_putraw(handle_t handle, const uint8_t *data, uint8_t size, async_callback_t callback, void *ptr){
	ssd1306_device_t *dev = (ssd1306_device_t*)handle;
	
	memcpy(dev->_data, data, size);
	dev->_data_size = size;
	
	dev->__callback = callback;
	dev->__arg = ptr;

	uint8_t col = dev->addr & 0x7f;
	
	uint8_t buffer[] = {
		U8G_ESC_ADR(0),           // instruction mode 
		U8G_ESC_CS(1),             // enable chip 
		0x000 | (col & 0x0f),		// set lower 4 bit of the col adr to 0 
		0x010 | ((col >> 4) & 0x0f),		// set higher 4 bit of the col adr to 0 
		0x0b0 | (dev->addr >> 7) & 0x0f,  	// page address
		U8G_ESC_END,                // end of sequence 
	};
	
	dev->addr += dev->_data_size;

	__run_commands(handle, buffer, sizeof(buffer), _fill_display_data, handle); 
}

void _each_letter(void *block, uint8_t *it, uint8_t last, void *arg, void (*callback)(void *block)){
	struct ssd1306_device *dev = (ssd1306_device_t*)arg;


}

void ssd1306_drawText(handle_t h, uint8_t *str, async_callback_t callback, void *ptr){
	
	async_schedule_each(str, 1, strlen(str), _each_letter, h); 
}
/// executes the display init sequence that powers on the display
static void __init_display(handle_t dev, async_callback_t callback, void *arg) {
	uint8_t buffer[] = {
		U8G_ESC_CS(0),             /* disable chip */
		U8G_ESC_ADR(0),           /* instruction mode */
		U8G_ESC_RST(1),           /* do reset low pulse with (1*16)+2 milliseconds */
		U8G_ESC_CS(1),             /* enable chip */
		
		0x0ae,				/* display off, sleep mode */
		0x0d5, 0x081,		/* clock divide ratio (0x00=1) and oscillator frequency (0x8) */
		0x0a8, 0x03f,		/* multiplex ratio */
		0x0d3, 0x000,	0x00,	/* display offset */
		//0x040,				/* start line */
		0x08d, 0x014,		/* charge pump setting (p62): 0x014 enable, 0x010 disable */
		0x20, 0x00, // memory addr mode
		0x0a1,				/* segment remap a0/a1*/
		0xa5, // display on
		0x0c8,				/* c0: scan dir normal, c8: reverse */
		0x0da, 0x012,		/* com pin HW config, sequential com pin config (bit 4), disable left/right remap (bit 5) */
		0x081, 0x09f,		/* set contrast control */
		0x0d9, 0x011,		/* pre-charge period */
		0x0db, 0x020,		/* vcomh deselect level */
		//0x022, 0x000,		/* page addressing mode WRONG: 3 byte cmd! */
		0x0a4,				/* output ram to display */
		0x0a6,				/* none inverted normal display mode */
		0x0af,				/* display on */
  
		//U8G_ESC_CS(0),             /* disable chip */
		U8G_ESC_END                /* end of sequence */
		
	};
	
	__run_commands(dev, buffer, sizeof(buffer), callback, arg); 
}


void ssd1306_invertDisplay(handle_t dev, uint8_t i) {
	uint8_t command[1]; 
  if (i) {
    command[0] = SSD1306_INVERTDISPLAY;
  } else {
    command[0] = SSD1306_NORMALDISPLAY;
  }
  __run_commands(dev, command, 1, 0, 0); 
}


// startscrollright
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void ssd1306_startscrollright(handle_t dev, uint8_t start, uint8_t stop){
	uint8_t buffer[] = {
			SSD1306_RIGHT_HORIZONTAL_SCROLL,
			0x00, start, 0x00, stop, 0x01, 0xff,
			SSD1306_ACTIVATE_SCROLL
	};
	__run_commands(dev, buffer, sizeof(buffer), 0, 0); 
	/*
	ssd1306_command(SSD1306_RIGHT_HORIZONTAL_SCROLL);
	ssd1306_command(0X00);
	ssd1306_command(start);
	ssd1306_command(0X00);
	ssd1306_command(stop);
	ssd1306_command(0X01);
	ssd1306_command(0XFF);
	ssd1306_command(SSD1306_ACTIVATE_SCROLL);*/
}

// startscrollleft
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void ssd1306_startscrollleft(handle_t dev, uint8_t start, uint8_t stop){
	uint8_t buffer[] = {
			SSD1306_RIGHT_HORIZONTAL_SCROLL,
			0x00,
			start,
			0x00,
			stop,
			0x01,
			0xff,
			SSD1306_ACTIVATE_SCROLL
	};
	__run_commands(dev, buffer, sizeof(buffer), 0, 0); 
	/*ssd1306_command(SSD1306_LEFT_HORIZONTAL_SCROLL);
	ssd1306_command(0X00);
	ssd1306_command(start);
	ssd1306_command(0X00);
	ssd1306_command(stop);
	ssd1306_command(0X01);
	ssd1306_command(0XFF);
	ssd1306_command(SSD1306_ACTIVATE_SCROLL);*/
}

// startscrolldiagright
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void ssd1306_startscrolldiagright(handle_t dev, uint8_t start, uint8_t stop){
	uint8_t buffer[] = {
			SSD1306_SET_VERTICAL_SCROLL_AREA,
			0x00,
			SSD1306_LCDHEIGHT,
			SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL,
			0x0,
			start,
			0x00,
			stop,
			0x01,
			SSD1306_ACTIVATE_SCROLL
	};
	__run_commands(dev, buffer, sizeof(buffer), 0, 0);
	/*
	ssd1306_command(SSD1306_SET_VERTICAL_SCROLL_AREA);
	ssd1306_command(0X00);
	ssd1306_command(SSD1306_LCDHEIGHT);
	ssd1306_command(SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL);
	ssd1306_command(0X00);
	ssd1306_command(start);
	ssd1306_command(0X00);
	ssd1306_command(stop);
	ssd1306_command(0X01);
	ssd1306_command(SSD1306_ACTIVATE_SCROLL);*/
}

// startscrolldiagleft
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
/*void SSD1306::startscrolldiagleft(uint8_t start, uint8_t stop){
	ssd1306_command(SSD1306_SET_VERTICAL_SCROLL_AREA);
	ssd1306_command(0X00);
	ssd1306_command(SSD1306_LCDHEIGHT);
	ssd1306_command(SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL);
	ssd1306_command(0X00);
	ssd1306_command(start);
	ssd1306_command(0X00);
	ssd1306_command(stop);
	ssd1306_command(0X01);
	ssd1306_command(SSD1306_ACTIVATE_SCROLL);
}

void SSD1306::stopscroll(void){
	ssd1306_command(SSD1306_DEACTIVATE_SCROLL);
}*/

/*
static void ssd1306_fill(unsigned char dat)
{
	unsigned char i,j;

	ssd1306_command(0x00);//set lower column address
	ssd1306_command(0x10);//set higher column address
	ssd1306_command(0xB0);//set page address

	for (byte i=0; i<(SSD1306_LCDHEIGHT/8); i++)
	{
			// send a bunch of data in one xmission
			ssd1306_command(0xB0 + i);//set page address
			ssd1306_command(0);//set lower column address
			ssd1306_command(0x10);//set higher column address

			for(byte j = 0; j < 8; j++){
					Wire.beginTransmission(_i2caddr);
					Wire.write(0x40);
					for (byte k = 0; k < 16; k++) {
							Wire.write(dat);
					}
					Wire.endTransmission();
			}
	}
}

void ssd1306_draw8x8(uint8_t* buffer, uint8_t x, uint8_t y){
	// send a bunch of data in one xmission
	ssd1306_command(0xB0 + y);//set page address
	ssd1306_command(x & 0xf);//set lower column address
	ssd1306_command(0x10 | (x >> 4));//set higher column address

	Wire.beginTransmission(_i2caddr);
	Wire.write(0x40);
	Wire.write(buffer, 8);
	Wire.endTransmission();
}
*/

CONSTRUCTOR(ssd1306_setup){
	i2c = i2c_open(0);
}

#ifdef __AVR__
#include <avr/io.h>
#include <avr/pgmspace.h>
#else
#define PROGMEM
#endif

// Standard ASCII 5x7 font
static const unsigned char font[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00,
0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
0x18, 0x3C, 0x7E, 0x3C, 0x18,
0x1C, 0x57, 0x7D, 0x57, 0x1C,
0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
0x00, 0x18, 0x3C, 0x18, 0x00,
0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
0x00, 0x18, 0x24, 0x18, 0x00,
0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
0x30, 0x48, 0x3A, 0x06, 0x0E,
0x26, 0x29, 0x79, 0x29, 0x26,
0x40, 0x7F, 0x05, 0x05, 0x07,
0x40, 0x7F, 0x05, 0x25, 0x3F,
0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
0x7F, 0x3E, 0x1C, 0x1C, 0x08,
0x08, 0x1C, 0x1C, 0x3E, 0x7F,
0x14, 0x22, 0x7F, 0x22, 0x14,
0x5F, 0x5F, 0x00, 0x5F, 0x5F,
0x06, 0x09, 0x7F, 0x01, 0x7F,
0x00, 0x66, 0x89, 0x95, 0x6A,
0x60, 0x60, 0x60, 0x60, 0x60,
0x94, 0xA2, 0xFF, 0xA2, 0x94,
0x08, 0x04, 0x7E, 0x04, 0x08,
0x10, 0x20, 0x7E, 0x20, 0x10,
0x08, 0x08, 0x2A, 0x1C, 0x08,
0x08, 0x1C, 0x2A, 0x08, 0x08,
0x1E, 0x10, 0x10, 0x10, 0x10,
0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
0x30, 0x38, 0x3E, 0x38, 0x30,
0x06, 0x0E, 0x3E, 0x0E, 0x06,
0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x5F, 0x00, 0x00,
0x00, 0x07, 0x00, 0x07, 0x00,
0x14, 0x7F, 0x14, 0x7F, 0x14,
0x24, 0x2A, 0x7F, 0x2A, 0x12,
0x23, 0x13, 0x08, 0x64, 0x62,
0x36, 0x49, 0x56, 0x20, 0x50,
0x00, 0x08, 0x07, 0x03, 0x00,
0x00, 0x1C, 0x22, 0x41, 0x00,
0x00, 0x41, 0x22, 0x1C, 0x00,
0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
0x08, 0x08, 0x3E, 0x08, 0x08,
0x00, 0x80, 0x70, 0x30, 0x00,
0x08, 0x08, 0x08, 0x08, 0x08,
0x00, 0x00, 0x60, 0x60, 0x00,
0x20, 0x10, 0x08, 0x04, 0x02,
0x3E, 0x51, 0x49, 0x45, 0x3E,
0x00, 0x42, 0x7F, 0x40, 0x00,
0x72, 0x49, 0x49, 0x49, 0x46,
0x21, 0x41, 0x49, 0x4D, 0x33,
0x18, 0x14, 0x12, 0x7F, 0x10,
0x27, 0x45, 0x45, 0x45, 0x39,
0x3C, 0x4A, 0x49, 0x49, 0x31,
0x41, 0x21, 0x11, 0x09, 0x07,
0x36, 0x49, 0x49, 0x49, 0x36,
0x46, 0x49, 0x49, 0x29, 0x1E,
0x00, 0x00, 0x14, 0x00, 0x00,
0x00, 0x40, 0x34, 0x00, 0x00,
0x00, 0x08, 0x14, 0x22, 0x41,
0x14, 0x14, 0x14, 0x14, 0x14,
0x00, 0x41, 0x22, 0x14, 0x08,
0x02, 0x01, 0x59, 0x09, 0x06,
0x3E, 0x41, 0x5D, 0x59, 0x4E,
0x7C, 0x12, 0x11, 0x12, 0x7C,
0x7F, 0x49, 0x49, 0x49, 0x36,
0x3E, 0x41, 0x41, 0x41, 0x22,
0x7F, 0x41, 0x41, 0x41, 0x3E,
0x7F, 0x49, 0x49, 0x49, 0x41,
0x7F, 0x09, 0x09, 0x09, 0x01,
0x3E, 0x41, 0x41, 0x51, 0x73,
0x7F, 0x08, 0x08, 0x08, 0x7F,
0x00, 0x41, 0x7F, 0x41, 0x00,
0x20, 0x40, 0x41, 0x3F, 0x01,
0x7F, 0x08, 0x14, 0x22, 0x41,
0x7F, 0x40, 0x40, 0x40, 0x40,
0x7F, 0x02, 0x1C, 0x02, 0x7F,
0x7F, 0x04, 0x08, 0x10, 0x7F,
0x3E, 0x41, 0x41, 0x41, 0x3E,
0x7F, 0x09, 0x09, 0x09, 0x06,
0x3E, 0x41, 0x51, 0x21, 0x5E,
0x7F, 0x09, 0x19, 0x29, 0x46,
0x26, 0x49, 0x49, 0x49, 0x32,
0x03, 0x01, 0x7F, 0x01, 0x03,
0x3F, 0x40, 0x40, 0x40, 0x3F,
0x1F, 0x20, 0x40, 0x20, 0x1F,
0x3F, 0x40, 0x38, 0x40, 0x3F,
0x63, 0x14, 0x08, 0x14, 0x63,
0x03, 0x04, 0x78, 0x04, 0x03,
0x61, 0x59, 0x49, 0x4D, 0x43,
0x00, 0x7F, 0x41, 0x41, 0x41,
0x02, 0x04, 0x08, 0x10, 0x20,
0x00, 0x41, 0x41, 0x41, 0x7F,
0x04, 0x02, 0x01, 0x02, 0x04,
0x40, 0x40, 0x40, 0x40, 0x40,
0x00, 0x03, 0x07, 0x08, 0x00,
0x20, 0x54, 0x54, 0x78, 0x40,
0x7F, 0x28, 0x44, 0x44, 0x38,
0x38, 0x44, 0x44, 0x44, 0x28,
0x38, 0x44, 0x44, 0x28, 0x7F,
0x38, 0x54, 0x54, 0x54, 0x18,
0x00, 0x08, 0x7E, 0x09, 0x02,
0x18, 0xA4, 0xA4, 0x9C, 0x78,
0x7F, 0x08, 0x04, 0x04, 0x78,
0x00, 0x44, 0x7D, 0x40, 0x00,
0x20, 0x40, 0x40, 0x3D, 0x00,
0x7F, 0x10, 0x28, 0x44, 0x00,
0x00, 0x41, 0x7F, 0x40, 0x00,
0x7C, 0x04, 0x78, 0x04, 0x78,
0x7C, 0x08, 0x04, 0x04, 0x78,
0x38, 0x44, 0x44, 0x44, 0x38,
0xFC, 0x18, 0x24, 0x24, 0x18,
0x18, 0x24, 0x24, 0x18, 0xFC,
0x7C, 0x08, 0x04, 0x04, 0x08,
0x48, 0x54, 0x54, 0x54, 0x24,
0x04, 0x04, 0x3F, 0x44, 0x24,
0x3C, 0x40, 0x40, 0x20, 0x7C,
0x1C, 0x20, 0x40, 0x20, 0x1C,
0x3C, 0x40, 0x30, 0x40, 0x3C,
0x44, 0x28, 0x10, 0x28, 0x44,
0x4C, 0x90, 0x90, 0x90, 0x7C,
0x44, 0x64, 0x54, 0x4C, 0x44,
0x00, 0x08, 0x36, 0x41, 0x00,
0x00, 0x00, 0x77, 0x00, 0x00,
0x00, 0x41, 0x36, 0x08, 0x00,
0x02, 0x01, 0x02, 0x04, 0x02,
0x3C, 0x26, 0x23, 0x26, 0x3C,
0x1E, 0xA1, 0xA1, 0x61, 0x12,
0x3A, 0x40, 0x40, 0x20, 0x7A,
0x38, 0x54, 0x54, 0x55, 0x59,
0x21, 0x55, 0x55, 0x79, 0x41,
0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut
0x21, 0x55, 0x54, 0x78, 0x40,
0x20, 0x54, 0x55, 0x79, 0x40,
0x0C, 0x1E, 0x52, 0x72, 0x12,
0x39, 0x55, 0x55, 0x55, 0x59,
0x39, 0x54, 0x54, 0x54, 0x59,
0x39, 0x55, 0x54, 0x54, 0x58,
0x00, 0x00, 0x45, 0x7C, 0x41,
0x00, 0x02, 0x45, 0x7D, 0x42,
0x00, 0x01, 0x45, 0x7C, 0x40,
0x7D, 0x12, 0x11, 0x12, 0x7D, // A-umlaut
0xF0, 0x28, 0x25, 0x28, 0xF0,
0x7C, 0x54, 0x55, 0x45, 0x00,
0x20, 0x54, 0x54, 0x7C, 0x54,
0x7C, 0x0A, 0x09, 0x7F, 0x49,
0x32, 0x49, 0x49, 0x49, 0x32,
0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut
0x32, 0x4A, 0x48, 0x48, 0x30,
0x3A, 0x41, 0x41, 0x21, 0x7A,
0x3A, 0x42, 0x40, 0x20, 0x78,
0x00, 0x9D, 0xA0, 0xA0, 0x7D,
0x3D, 0x42, 0x42, 0x42, 0x3D, // O-umlaut
0x3D, 0x40, 0x40, 0x40, 0x3D,
0x3C, 0x24, 0xFF, 0x24, 0x24,
0x48, 0x7E, 0x49, 0x43, 0x66,
0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
0xFF, 0x09, 0x29, 0xF6, 0x20,
0xC0, 0x88, 0x7E, 0x09, 0x03,
0x20, 0x54, 0x54, 0x79, 0x41,
0x00, 0x00, 0x44, 0x7D, 0x41,
0x30, 0x48, 0x48, 0x4A, 0x32,
0x38, 0x40, 0x40, 0x22, 0x7A,
0x00, 0x7A, 0x0A, 0x0A, 0x72,
0x7D, 0x0D, 0x19, 0x31, 0x7D,
0x26, 0x29, 0x29, 0x2F, 0x28,
0x26, 0x29, 0x29, 0x29, 0x26,
0x30, 0x48, 0x4D, 0x40, 0x20,
0x38, 0x08, 0x08, 0x08, 0x08,
0x08, 0x08, 0x08, 0x08, 0x38,
0x2F, 0x10, 0xC8, 0xAC, 0xBA,
0x2F, 0x10, 0x28, 0x34, 0xFA,
0x00, 0x00, 0x7B, 0x00, 0x00,
0x08, 0x14, 0x2A, 0x14, 0x22,
0x22, 0x14, 0x2A, 0x14, 0x08,
0xAA, 0x00, 0x55, 0x00, 0xAA,
0xAA, 0x55, 0xAA, 0x55, 0xAA,
0x00, 0x00, 0x00, 0xFF, 0x00,
0x10, 0x10, 0x10, 0xFF, 0x00,
0x14, 0x14, 0x14, 0xFF, 0x00,
0x10, 0x10, 0xFF, 0x00, 0xFF,
0x10, 0x10, 0xF0, 0x10, 0xF0,
0x14, 0x14, 0x14, 0xFC, 0x00,
0x14, 0x14, 0xF7, 0x00, 0xFF,
0x00, 0x00, 0xFF, 0x00, 0xFF,
0x14, 0x14, 0xF4, 0x04, 0xFC,
0x14, 0x14, 0x17, 0x10, 0x1F,
0x10, 0x10, 0x1F, 0x10, 0x1F,
0x14, 0x14, 0x14, 0x1F, 0x00,
0x10, 0x10, 0x10, 0xF0, 0x00,
0x00, 0x00, 0x00, 0x1F, 0x10,
0x10, 0x10, 0x10, 0x1F, 0x10,
0x10, 0x10, 0x10, 0xF0, 0x10,
0x00, 0x00, 0x00, 0xFF, 0x10,
0x10, 0x10, 0x10, 0x10, 0x10,
0x10, 0x10, 0x10, 0xFF, 0x10,
0x00, 0x00, 0x00, 0xFF, 0x14,
0x00, 0x00, 0xFF, 0x00, 0xFF,
0x00, 0x00, 0x1F, 0x10, 0x17,
0x00, 0x00, 0xFC, 0x04, 0xF4,
0x14, 0x14, 0x17, 0x10, 0x17,
0x14, 0x14, 0xF4, 0x04, 0xF4,
0x00, 0x00, 0xFF, 0x00, 0xF7,
0x14, 0x14, 0x14, 0x14, 0x14,
0x14, 0x14, 0xF7, 0x00, 0xF7,
0x14, 0x14, 0x14, 0x17, 0x14,
0x10, 0x10, 0x1F, 0x10, 0x1F,
0x14, 0x14, 0x14, 0xF4, 0x14,
0x10, 0x10, 0xF0, 0x10, 0xF0,
0x00, 0x00, 0x1F, 0x10, 0x1F,
0x00, 0x00, 0x00, 0x1F, 0x14,
0x00, 0x00, 0x00, 0xFC, 0x14,
0x00, 0x00, 0xF0, 0x10, 0xF0,
0x10, 0x10, 0xFF, 0x10, 0xFF,
0x14, 0x14, 0x14, 0xFF, 0x14,
0x10, 0x10, 0x10, 0x1F, 0x00,
0x00, 0x00, 0x00, 0xF0, 0x10,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
0xFF, 0xFF, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x00, 0xFF, 0xFF,
0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
0x38, 0x44, 0x44, 0x38, 0x44,
0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta
0x7E, 0x02, 0x02, 0x06, 0x06,
0x02, 0x7E, 0x02, 0x7E, 0x02,
0x63, 0x55, 0x49, 0x41, 0x63,
0x38, 0x44, 0x44, 0x3C, 0x04,
0x40, 0x7E, 0x20, 0x1E, 0x20,
0x06, 0x02, 0x7E, 0x02, 0x02,
0x99, 0xA5, 0xE7, 0xA5, 0x99,
0x1C, 0x2A, 0x49, 0x2A, 0x1C,
0x4C, 0x72, 0x01, 0x72, 0x4C,
0x30, 0x4A, 0x4D, 0x4D, 0x30,
0x30, 0x48, 0x78, 0x48, 0x30,
0xBC, 0x62, 0x5A, 0x46, 0x3D,
0x3E, 0x49, 0x49, 0x49, 0x00,
0x7E, 0x01, 0x01, 0x01, 0x7E,
0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
0x44, 0x44, 0x5F, 0x44, 0x44,
0x40, 0x51, 0x4A, 0x44, 0x40,
0x40, 0x44, 0x4A, 0x51, 0x40,
0x00, 0x00, 0xFF, 0x01, 0x03,
0xE0, 0x80, 0xFF, 0x00, 0x00,
0x08, 0x08, 0x6B, 0x6B, 0x08,
0x36, 0x12, 0x36, 0x24, 0x36,
0x06, 0x0F, 0x09, 0x0F, 0x06,
0x00, 0x00, 0x18, 0x18, 0x00,
0x00, 0x00, 0x10, 0x10, 0x00,
0x30, 0x40, 0xFF, 0x01, 0x01,
0x00, 0x1F, 0x01, 0x01, 0x1E,
0x00, 0x19, 0x1D, 0x17, 0x12,
0x00, 0x3C, 0x3C, 0x3C, 0x3C,
0x00, 0x00, 0x00, 0x00, 0x00
};

void ssd1306_get_glyph(uint8_t ch, char *glyph){
	for(int c = 0; c < 5; c++){
		*(glyph++) = pgm_read_byte(&(font[5 * ch + c]));
	}
}
