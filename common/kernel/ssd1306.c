/*******
 * I2C asynchronous driver for ssd1306 series 128x64 point displays
 *
 * License: GPLv3
 * Author: Martin K. Schr√∂der
 * Email: info@fortmax.se
 * Website: http://oskit.se
 */

#include <avr/pgmspace.h>
#include <stdlib.h>

#include <kernel/device.h>
#include <kernel/i2c.h>
#include <kernel/ssd1306.h>

#include "../drivers/uart.h"

#include <string.h>

#define DISPLAY_ADDRESS 0x78

#define U8G_ESC_CS(x) 255, (0xd0 | ((x)&0x0f))
#define U8G_ESC_ADR(x) 255, (0xe0 | ((x)&0x0f))
#define U8G_ESC_RST(x) 255, (0xc0 | ((x)&0x0f))
#define U8G_ESC_END 255, 254

struct ssd1306_request {
	struct {
		uint8_t command : 1;
		uint8_t text : 1;
		uint8_t pgmem : 1; 
	} flags;
	//uint8_t addr; 
	uint8_t *data;
	uint16_t ptr; 
	uint16_t size;
};

// types of requests:
// init: one long command request
// scroll: one small command request
// data: one command, then data request
// text: 
typedef struct ssd1306_device {
	struct {
		uint8_t in_use : 1; 
		uint8_t busy : 1;
	} flags;

	// user callback
	async_callback_t callback;
	void *arg;

	// callbacks used for internal ops
	async_callback_t __callback;
	void *__arg;
	
	uint8_t _commands[32]; // command buffer
	uint8_t _data[64];
	uint8_t _data_size;

	struct ssd1306_request request[4];
	uint8_t request_ptr;
	uint8_t request_size;
	
	uint16_t addr;  // byte address in the display ram
} ssd1306_device_t;

static ssd1306_device_t _device[1];
static handle_t i2c = 0;
static const unsigned char font[];

void ssd1306_get_glyph(uint8_t ch, char *glyph); 

static void __init_display(handle_t dev, async_callback_t cb, void *arg);

handle_t ssd1306_open(id_t id){
	ssd1306_device_t *dev = &_device[0];
	if(dev->flags.in_use) return INVALID_HANDLE;
	dev->flags.in_use = 1;
	dev->flags.busy = 0;
	return dev;
}

int8_t ssd1306_init(handle_t dev, async_callback_t callback, void *ptr){
	__init_display(dev, callback, ptr);
	return SUCCESS; 
}

static void __process(void *arg) {
	ssd1306_device_t *dev = (ssd1306_device_t*)arg;
	struct ssd1306_request *req = &dev->request[dev->request_ptr];
	
	static uint8_t buffer[2];

	if(req->flags.command)
		buffer[0] = 0x00;
	else {
		buffer[0] = 0x40;
		dev->addr++;
	}
	if(req->flags.pgmem){
		buffer[1] = pgm_read_byte(&req->data[req->ptr]);
		req->ptr++;
	}
	else if(req->flags.text){
		//uint16_t col = (dev->addr & 0x1ff);
		
		if((req->ptr & 0x07) > 5){
			req->ptr &= ~0x07; // next char;
			req->ptr += 8; 
		}
		uint8_t ch = req->data[req->ptr >> 3];
		uint8_t col = (req->ptr & 0x07);
		req->ptr++;
		
		if(col < 5) // next four cols are just font stuff
			buffer[1] = pgm_read_byte(&font[ch * 5 + (col)]);
		else if(col == 5) // last one is letter separator
			buffer[1] = 0;
			
	} else {
		buffer[1] = req->data[req->ptr];
		req->ptr++;
	}

	if(req->ptr >= req->size){
		dev->request_ptr++;
		if(dev->request_ptr >= dev->request_size){
			dev->flags.busy = 0;
			async_schedule(dev->callback, dev->arg, 0);
			return; 
		}
	}
	
	// send the i2c command to the i2c driver and have it call
	// supplied callback when the transfer is completed
	i2c_transfer(i2c, (i2c_command_t){
		.addr = DISPLAY_ADDRESS,
		.buf = buffer,
		.wcount = 2,
		.rcount = 0,
		.callback = __process,
		.arg = dev
	});
}

/// Write raw buffer into the desplay. 
int8_t ssd1306_putstring(handle_t handle, const uint8_t *data, uint8_t size, async_callback_t callback, void *ptr){
	struct ssd1306_device *dev = (ssd1306_device_t*)handle;

	//if((dev->addr & 0x7f) > 126) dev->addr += 2; 
	uint8_t col = dev->addr & 0x7f; // low 7 bits
	uint8_t row = (dev->addr >> 7) & 0xff;
	
	uint8_t buffer[] = {
		U8G_ESC_ADR(0),           // instruction mode 
		U8G_ESC_CS(1),             // enable chip 
		0x000 | (col & 0x0f),		// set lower 4 bit of the col adr to 0 
		0x010 | ((col >> 4) & 0x0f),		// set higher 4 bit of the col adr to 0 
		0x0b0 | row & 0x0f,  	// page address
		U8G_ESC_END,                // end of sequence 
	};

	memcpy(dev->_commands, buffer, sizeof(buffer)); 
	memcpy(dev->_data, data, size);
	
	dev->request[0] = (struct ssd1306_request){
		.data = dev->_commands,
		.flags.text = 0, 
		.flags.command = 1,
		.flags.pgmem = 0, 
		.ptr = 0,
		.size = sizeof(buffer)
	}; 
	dev->request[1] = (struct ssd1306_request){
		.data = dev->_data,
		.flags.text = 1, 
		.flags.command = 0,
		.flags.pgmem = 0, 
		.ptr = 0,
		.size = size * 8
	}; 
	
	dev->request_ptr = 0;
	dev->request_size = 2;
	
	dev->callback = callback;
	dev->arg = ptr;

	//dev->addr = 0;
	
	__process(dev);
	
	// copy the data into the internal buffer
}

int8_t ssd1306_putraw(handle_t handle, const uint8_t *data, uint8_t size, async_callback_t callback, void *ptr){
	ssd1306_device_t *dev = (ssd1306_device_t*)handle;

	uint8_t col = dev->addr & 0x7f;
	uint8_t row = (dev->addr >> 7) & 0x0f; 
		
	uint8_t buffer[] = {
		U8G_ESC_ADR(0),           // instruction mode 
		U8G_ESC_CS(1),             // enable chip 
		0x000 | (col & 0x0f),		// set lower 4 bit of the col adr to 0 
		0x010 | ((col >> 4) & 0x0f),		// set higher 4 bit of the col adr to 0 
		0x0b0 | row,  	// page address
		U8G_ESC_END,                // end of sequence 
	};

	memcpy(dev->_commands, buffer, sizeof(buffer)); 
	memcpy(dev->_data, data, size);
	
	dev->request[0] = (struct ssd1306_request){
		.data = dev->_commands,
		.flags.text = 0, 
		.flags.command = 1,
		.flags.pgmem = 0, 
		.ptr = 0,
		.size = sizeof(buffer)
	}; 
	dev->request[1] = (struct ssd1306_request){
		.data = dev->_data,
		.flags.text = 0, 
		.flags.command = 0,
		.flags.pgmem = 0,
		.ptr = 0,
		.size = size
	}; 
	
	dev->request_ptr = 0;
	dev->request_size = 2;
	
	dev->callback = callback;
	dev->arg = ptr;

	//dev->addr = 0; 
	__process(dev);
}

void ssd1306_seek(handle_t h, uint16_t addr){
	struct ssd1306_device* dev = (struct ssd1306_device*)h;
	dev->addr = addr;
}

static const uint8_t init_sequence[] PROGMEM = {
	U8G_ESC_CS(0),             //disable chip
	U8G_ESC_ADR(0),           /* instruction mode */
	U8G_ESC_RST(1),           /* do reset low pulse with (1*16)+2 milliseconds */
	U8G_ESC_CS(1),             /* enable chip */
	
	0x0ae,				/* display off, sleep mode */
	0x0d5, 0x081,		/* clock divide ratio (0x00=1) and oscillator frequency (0x8) */
	0x0a8, 0x03f,		/* multiplex ratio */
	0x0d3, 0x000,	0x00,	/* display offset */
	//0x040,				/* start line */
	0x08d, 0x014,		/* charge pump setting (p62): 0x014 enable, 0x010 disable */
	0x20, 0x00, // memory addr mode
	0x0a1,				/* segment remap a0/a1*/
	0xa5, // display on
	0x0c8,				/* c0: scan dir normal, c8: reverse */
	0x0da, 0x012,		/* com pin HW config, sequential com pin config (bit 4), disable left/right remap (bit 5) */
	0x081, 0x09f,		/* set contrast control */
	0x0d9, 0x011,		/* pre-charge period */
	0x0db, 0x020,		/* vcomh deselect level */
	//0x022, 0x000,		/* page addressing mode WRONG: 3 byte cmd! */
	0x0a4,				/* output ram to display */
	0x0a6,				/* none inverted normal display mode */
	0x0af,				/* display on */

	//U8G_ESC_CS(0),             /* disable chip */
	U8G_ESC_END                /* end of sequence */
};

/// executes the display init sequence that powers on the display
static void __init_display(handle_t h, async_callback_t callback, void *ptr) {
	struct ssd1306_device *dev = (struct ssd1306_device*)h;
	
	dev->request[0] = (struct ssd1306_request){
		.data = init_sequence,
		.flags.text = 0, 
		.flags.command = 1,
		.flags.pgmem = 1, 
		.ptr = 0,
		.size = sizeof(init_sequence)
	};
	
	dev->request_ptr = 0;
	dev->request_size = 1;
	
	dev->callback = callback;
	dev->arg = ptr;

	dev->addr = 0;
	
	__process(dev); 
}


void ssd1306_invertDisplay(handle_t dev, uint8_t i) {
	uint8_t command[1]; 
  if (i) {
    command[0] = SSD1306_INVERTDISPLAY;
  } else {
    command[0] = SSD1306_NORMALDISPLAY;
  }
  __run_commands(dev, command, 1, 0, 0); 
}


// startscrollright
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void ssd1306_startscrollright(handle_t dev, uint8_t start, uint8_t stop){
	uint8_t buffer[] = {
			SSD1306_RIGHT_HORIZONTAL_SCROLL,
			0x00, start, 0x00, stop, 0x01, 0xff,
			SSD1306_ACTIVATE_SCROLL
	};
	__run_commands(dev, buffer, sizeof(buffer), 0, 0); 
	/*
	ssd1306_command(SSD1306_RIGHT_HORIZONTAL_SCROLL);
	ssd1306_command(0X00);
	ssd1306_command(start);
	ssd1306_command(0X00);
	ssd1306_command(stop);
	ssd1306_command(0X01);
	ssd1306_command(0XFF);
	ssd1306_command(SSD1306_ACTIVATE_SCROLL);*/
}

// startscrollleft
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void ssd1306_startscrollleft(handle_t dev, uint8_t start, uint8_t stop){
	uint8_t buffer[] = {
			SSD1306_RIGHT_HORIZONTAL_SCROLL,
			0x00,
			start,
			0x00,
			stop,
			0x01,
			0xff,
			SSD1306_ACTIVATE_SCROLL
	};
	__run_commands(dev, buffer, sizeof(buffer), 0, 0); 
	/*ssd1306_command(SSD1306_LEFT_HORIZONTAL_SCROLL);
	ssd1306_command(0X00);
	ssd1306_command(start);
	ssd1306_command(0X00);
	ssd1306_command(stop);
	ssd1306_command(0X01);
	ssd1306_command(0XFF);
	ssd1306_command(SSD1306_ACTIVATE_SCROLL);*/
}

// startscrolldiagright
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void ssd1306_startscrolldiagright(handle_t dev, uint8_t start, uint8_t stop){
	uint8_t buffer[] = {
			SSD1306_SET_VERTICAL_SCROLL_AREA,
			0x00,
			SSD1306_LCDHEIGHT,
			SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL,
			0x0,
			start,
			0x00,
			stop,
			0x01,
			SSD1306_ACTIVATE_SCROLL
	};
	__run_commands(dev, buffer, sizeof(buffer), 0, 0);
	/*
	ssd1306_command(SSD1306_SET_VERTICAL_SCROLL_AREA);
	ssd1306_command(0X00);
	ssd1306_command(SSD1306_LCDHEIGHT);
	ssd1306_command(SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL);
	ssd1306_command(0X00);
	ssd1306_command(start);
	ssd1306_command(0X00);
	ssd1306_command(stop);
	ssd1306_command(0X01);
	ssd1306_command(SSD1306_ACTIVATE_SCROLL);*/
}

// startscrolldiagleft
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
/*void SSD1306::startscrolldiagleft(uint8_t start, uint8_t stop){
	ssd1306_command(SSD1306_SET_VERTICAL_SCROLL_AREA);
	ssd1306_command(0X00);
	ssd1306_command(SSD1306_LCDHEIGHT);
	ssd1306_command(SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL);
	ssd1306_command(0X00);
	ssd1306_command(start);
	ssd1306_command(0X00);
	ssd1306_command(stop);
	ssd1306_command(0X01);
	ssd1306_command(SSD1306_ACTIVATE_SCROLL);
}

void SSD1306::stopscroll(void){
	ssd1306_command(SSD1306_DEACTIVATE_SCROLL);
}*/

/*
static void ssd1306_fill(unsigned char dat)
{
	unsigned char i,j;

	ssd1306_command(0x00);//set lower column address
	ssd1306_command(0x10);//set higher column address
	ssd1306_command(0xB0);//set page address

	for (byte i=0; i<(SSD1306_LCDHEIGHT/8); i++)
	{
			// send a bunch of data in one xmission
			ssd1306_command(0xB0 + i);//set page address
			ssd1306_command(0);//set lower column address
			ssd1306_command(0x10);//set higher column address

			for(byte j = 0; j < 8; j++){
					Wire.beginTransmission(_i2caddr);
					Wire.write(0x40);
					for (byte k = 0; k < 16; k++) {
							Wire.write(dat);
					}
					Wire.endTransmission();
			}
	}
}

void ssd1306_draw8x8(uint8_t* buffer, uint8_t x, uint8_t y){
	// send a bunch of data in one xmission
	ssd1306_command(0xB0 + y);//set page address
	ssd1306_command(x & 0xf);//set lower column address
	ssd1306_command(0x10 | (x >> 4));//set higher column address

	Wire.beginTransmission(_i2caddr);
	Wire.write(0x40);
	Wire.write(buffer, 8);
	Wire.endTransmission();
}
*/

CONSTRUCTOR(ssd1306_setup){
	i2c = i2c_open(0);
}

#ifdef __AVR__
#include <avr/io.h>
#include <avr/pgmspace.h>
#else
#define PROGMEM
#endif

// Standard ASCII 5x7 font
static const unsigned char font[] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00,
0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
0x18, 0x3C, 0x7E, 0x3C, 0x18,
0x1C, 0x57, 0x7D, 0x57, 0x1C,
0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
0x00, 0x18, 0x3C, 0x18, 0x00,
0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
0x00, 0x18, 0x24, 0x18, 0x00,
0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
0x30, 0x48, 0x3A, 0x06, 0x0E,
0x26, 0x29, 0x79, 0x29, 0x26,
0x40, 0x7F, 0x05, 0x05, 0x07,
0x40, 0x7F, 0x05, 0x25, 0x3F,
0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
0x7F, 0x3E, 0x1C, 0x1C, 0x08,
0x08, 0x1C, 0x1C, 0x3E, 0x7F,
0x14, 0x22, 0x7F, 0x22, 0x14,
0x5F, 0x5F, 0x00, 0x5F, 0x5F,
0x06, 0x09, 0x7F, 0x01, 0x7F,
0x00, 0x66, 0x89, 0x95, 0x6A,
0x60, 0x60, 0x60, 0x60, 0x60,
0x94, 0xA2, 0xFF, 0xA2, 0x94,
0x08, 0x04, 0x7E, 0x04, 0x08,
0x10, 0x20, 0x7E, 0x20, 0x10,
0x08, 0x08, 0x2A, 0x1C, 0x08,
0x08, 0x1C, 0x2A, 0x08, 0x08,
0x1E, 0x10, 0x10, 0x10, 0x10,
0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
0x30, 0x38, 0x3E, 0x38, 0x30,
0x06, 0x0E, 0x3E, 0x0E, 0x06,
0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x5F, 0x00, 0x00,
0x00, 0x07, 0x00, 0x07, 0x00,
0x14, 0x7F, 0x14, 0x7F, 0x14,
0x24, 0x2A, 0x7F, 0x2A, 0x12,
0x23, 0x13, 0x08, 0x64, 0x62,
0x36, 0x49, 0x56, 0x20, 0x50,
0x00, 0x08, 0x07, 0x03, 0x00,
0x00, 0x1C, 0x22, 0x41, 0x00,
0x00, 0x41, 0x22, 0x1C, 0x00,
0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
0x08, 0x08, 0x3E, 0x08, 0x08,
0x00, 0x80, 0x70, 0x30, 0x00,
0x08, 0x08, 0x08, 0x08, 0x08,
0x00, 0x00, 0x60, 0x60, 0x00,
0x20, 0x10, 0x08, 0x04, 0x02,
0x3E, 0x51, 0x49, 0x45, 0x3E,
0x00, 0x42, 0x7F, 0x40, 0x00,
0x72, 0x49, 0x49, 0x49, 0x46,
0x21, 0x41, 0x49, 0x4D, 0x33,
0x18, 0x14, 0x12, 0x7F, 0x10,
0x27, 0x45, 0x45, 0x45, 0x39,
0x3C, 0x4A, 0x49, 0x49, 0x31,
0x41, 0x21, 0x11, 0x09, 0x07,
0x36, 0x49, 0x49, 0x49, 0x36,
0x46, 0x49, 0x49, 0x29, 0x1E,
0x00, 0x00, 0x14, 0x00, 0x00,
0x00, 0x40, 0x34, 0x00, 0x00,
0x00, 0x08, 0x14, 0x22, 0x41,
0x14, 0x14, 0x14, 0x14, 0x14,
0x00, 0x41, 0x22, 0x14, 0x08,
0x02, 0x01, 0x59, 0x09, 0x06,
0x3E, 0x41, 0x5D, 0x59, 0x4E,
0x7C, 0x12, 0x11, 0x12, 0x7C,
0x7F, 0x49, 0x49, 0x49, 0x36,
0x3E, 0x41, 0x41, 0x41, 0x22,
0x7F, 0x41, 0x41, 0x41, 0x3E,
0x7F, 0x49, 0x49, 0x49, 0x41,
0x7F, 0x09, 0x09, 0x09, 0x01,
0x3E, 0x41, 0x41, 0x51, 0x73,
0x7F, 0x08, 0x08, 0x08, 0x7F,
0x00, 0x41, 0x7F, 0x41, 0x00,
0x20, 0x40, 0x41, 0x3F, 0x01,
0x7F, 0x08, 0x14, 0x22, 0x41,
0x7F, 0x40, 0x40, 0x40, 0x40,
0x7F, 0x02, 0x1C, 0x02, 0x7F,
0x7F, 0x04, 0x08, 0x10, 0x7F,
0x3E, 0x41, 0x41, 0x41, 0x3E,
0x7F, 0x09, 0x09, 0x09, 0x06,
0x3E, 0x41, 0x51, 0x21, 0x5E,
0x7F, 0x09, 0x19, 0x29, 0x46,
0x26, 0x49, 0x49, 0x49, 0x32,
0x03, 0x01, 0x7F, 0x01, 0x03,
0x3F, 0x40, 0x40, 0x40, 0x3F,
0x1F, 0x20, 0x40, 0x20, 0x1F,
0x3F, 0x40, 0x38, 0x40, 0x3F,
0x63, 0x14, 0x08, 0x14, 0x63,
0x03, 0x04, 0x78, 0x04, 0x03,
0x61, 0x59, 0x49, 0x4D, 0x43,
0x00, 0x7F, 0x41, 0x41, 0x41,
0x02, 0x04, 0x08, 0x10, 0x20,
0x00, 0x41, 0x41, 0x41, 0x7F,
0x04, 0x02, 0x01, 0x02, 0x04,
0x40, 0x40, 0x40, 0x40, 0x40,
0x00, 0x03, 0x07, 0x08, 0x00,
0x20, 0x54, 0x54, 0x78, 0x40,
0x7F, 0x28, 0x44, 0x44, 0x38,
0x38, 0x44, 0x44, 0x44, 0x28,
0x38, 0x44, 0x44, 0x28, 0x7F,
0x38, 0x54, 0x54, 0x54, 0x18,
0x00, 0x08, 0x7E, 0x09, 0x02,
0x18, 0xA4, 0xA4, 0x9C, 0x78,
0x7F, 0x08, 0x04, 0x04, 0x78,
0x00, 0x44, 0x7D, 0x40, 0x00,
0x20, 0x40, 0x40, 0x3D, 0x00,
0x7F, 0x10, 0x28, 0x44, 0x00,
0x00, 0x41, 0x7F, 0x40, 0x00,
0x7C, 0x04, 0x78, 0x04, 0x78,
0x7C, 0x08, 0x04, 0x04, 0x78,
0x38, 0x44, 0x44, 0x44, 0x38,
0xFC, 0x18, 0x24, 0x24, 0x18,
0x18, 0x24, 0x24, 0x18, 0xFC,
0x7C, 0x08, 0x04, 0x04, 0x08,
0x48, 0x54, 0x54, 0x54, 0x24,
0x04, 0x04, 0x3F, 0x44, 0x24,
0x3C, 0x40, 0x40, 0x20, 0x7C,
0x1C, 0x20, 0x40, 0x20, 0x1C,
0x3C, 0x40, 0x30, 0x40, 0x3C,
0x44, 0x28, 0x10, 0x28, 0x44,
0x4C, 0x90, 0x90, 0x90, 0x7C,
0x44, 0x64, 0x54, 0x4C, 0x44,
0x00, 0x08, 0x36, 0x41, 0x00,
0x00, 0x00, 0x77, 0x00, 0x00,
0x00, 0x41, 0x36, 0x08, 0x00,
0x02, 0x01, 0x02, 0x04, 0x02,
0x3C, 0x26, 0x23, 0x26, 0x3C,
0x1E, 0xA1, 0xA1, 0x61, 0x12,
0x3A, 0x40, 0x40, 0x20, 0x7A,
0x38, 0x54, 0x54, 0x55, 0x59,
0x21, 0x55, 0x55, 0x79, 0x41,
0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut
0x21, 0x55, 0x54, 0x78, 0x40,
0x20, 0x54, 0x55, 0x79, 0x40,
0x0C, 0x1E, 0x52, 0x72, 0x12,
0x39, 0x55, 0x55, 0x55, 0x59,
0x39, 0x54, 0x54, 0x54, 0x59,
0x39, 0x55, 0x54, 0x54, 0x58,
0x00, 0x00, 0x45, 0x7C, 0x41,
0x00, 0x02, 0x45, 0x7D, 0x42,
0x00, 0x01, 0x45, 0x7C, 0x40,
0x7D, 0x12, 0x11, 0x12, 0x7D, // A-umlaut
0xF0, 0x28, 0x25, 0x28, 0xF0,
0x7C, 0x54, 0x55, 0x45, 0x00,
0x20, 0x54, 0x54, 0x7C, 0x54,
0x7C, 0x0A, 0x09, 0x7F, 0x49,
0x32, 0x49, 0x49, 0x49, 0x32,
0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut
0x32, 0x4A, 0x48, 0x48, 0x30,
0x3A, 0x41, 0x41, 0x21, 0x7A,
0x3A, 0x42, 0x40, 0x20, 0x78,
0x00, 0x9D, 0xA0, 0xA0, 0x7D,
0x3D, 0x42, 0x42, 0x42, 0x3D, // O-umlaut
0x3D, 0x40, 0x40, 0x40, 0x3D,
0x3C, 0x24, 0xFF, 0x24, 0x24,
0x48, 0x7E, 0x49, 0x43, 0x66,
0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
0xFF, 0x09, 0x29, 0xF6, 0x20,
0xC0, 0x88, 0x7E, 0x09, 0x03,
0x20, 0x54, 0x54, 0x79, 0x41,
0x00, 0x00, 0x44, 0x7D, 0x41,
0x30, 0x48, 0x48, 0x4A, 0x32,
0x38, 0x40, 0x40, 0x22, 0x7A,
0x00, 0x7A, 0x0A, 0x0A, 0x72,
0x7D, 0x0D, 0x19, 0x31, 0x7D,
0x26, 0x29, 0x29, 0x2F, 0x28,
0x26, 0x29, 0x29, 0x29, 0x26,
0x30, 0x48, 0x4D, 0x40, 0x20,
0x38, 0x08, 0x08, 0x08, 0x08,
0x08, 0x08, 0x08, 0x08, 0x38,
0x2F, 0x10, 0xC8, 0xAC, 0xBA,
0x2F, 0x10, 0x28, 0x34, 0xFA,
0x00, 0x00, 0x7B, 0x00, 0x00,
0x08, 0x14, 0x2A, 0x14, 0x22,
0x22, 0x14, 0x2A, 0x14, 0x08,
0xAA, 0x00, 0x55, 0x00, 0xAA,
0xAA, 0x55, 0xAA, 0x55, 0xAA,
0x00, 0x00, 0x00, 0xFF, 0x00,
0x10, 0x10, 0x10, 0xFF, 0x00,
0x14, 0x14, 0x14, 0xFF, 0x00,
0x10, 0x10, 0xFF, 0x00, 0xFF,
0x10, 0x10, 0xF0, 0x10, 0xF0,
0x14, 0x14, 0x14, 0xFC, 0x00,
0x14, 0x14, 0xF7, 0x00, 0xFF,
0x00, 0x00, 0xFF, 0x00, 0xFF,
0x14, 0x14, 0xF4, 0x04, 0xFC,
0x14, 0x14, 0x17, 0x10, 0x1F,
0x10, 0x10, 0x1F, 0x10, 0x1F,
0x14, 0x14, 0x14, 0x1F, 0x00,
0x10, 0x10, 0x10, 0xF0, 0x00,
0x00, 0x00, 0x00, 0x1F, 0x10,
0x10, 0x10, 0x10, 0x1F, 0x10,
0x10, 0x10, 0x10, 0xF0, 0x10,
0x00, 0x00, 0x00, 0xFF, 0x10,
0x10, 0x10, 0x10, 0x10, 0x10,
0x10, 0x10, 0x10, 0xFF, 0x10,
0x00, 0x00, 0x00, 0xFF, 0x14,
0x00, 0x00, 0xFF, 0x00, 0xFF,
0x00, 0x00, 0x1F, 0x10, 0x17,
0x00, 0x00, 0xFC, 0x04, 0xF4,
0x14, 0x14, 0x17, 0x10, 0x17,
0x14, 0x14, 0xF4, 0x04, 0xF4,
0x00, 0x00, 0xFF, 0x00, 0xF7,
0x14, 0x14, 0x14, 0x14, 0x14,
0x14, 0x14, 0xF7, 0x00, 0xF7,
0x14, 0x14, 0x14, 0x17, 0x14,
0x10, 0x10, 0x1F, 0x10, 0x1F,
0x14, 0x14, 0x14, 0xF4, 0x14,
0x10, 0x10, 0xF0, 0x10, 0xF0,
0x00, 0x00, 0x1F, 0x10, 0x1F,
0x00, 0x00, 0x00, 0x1F, 0x14,
0x00, 0x00, 0x00, 0xFC, 0x14,
0x00, 0x00, 0xF0, 0x10, 0xF0,
0x10, 0x10, 0xFF, 0x10, 0xFF,
0x14, 0x14, 0x14, 0xFF, 0x14,
0x10, 0x10, 0x10, 0x1F, 0x00,
0x00, 0x00, 0x00, 0xF0, 0x10,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
0xFF, 0xFF, 0xFF, 0x00, 0x00,
0x00, 0x00, 0x00, 0xFF, 0xFF,
0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
0x38, 0x44, 0x44, 0x38, 0x44,
0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta
0x7E, 0x02, 0x02, 0x06, 0x06,
0x02, 0x7E, 0x02, 0x7E, 0x02,
0x63, 0x55, 0x49, 0x41, 0x63,
0x38, 0x44, 0x44, 0x3C, 0x04,
0x40, 0x7E, 0x20, 0x1E, 0x20,
0x06, 0x02, 0x7E, 0x02, 0x02,
0x99, 0xA5, 0xE7, 0xA5, 0x99,
0x1C, 0x2A, 0x49, 0x2A, 0x1C,
0x4C, 0x72, 0x01, 0x72, 0x4C,
0x30, 0x4A, 0x4D, 0x4D, 0x30,
0x30, 0x48, 0x78, 0x48, 0x30,
0xBC, 0x62, 0x5A, 0x46, 0x3D,
0x3E, 0x49, 0x49, 0x49, 0x00,
0x7E, 0x01, 0x01, 0x01, 0x7E,
0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
0x44, 0x44, 0x5F, 0x44, 0x44,
0x40, 0x51, 0x4A, 0x44, 0x40,
0x40, 0x44, 0x4A, 0x51, 0x40,
0x00, 0x00, 0xFF, 0x01, 0x03,
0xE0, 0x80, 0xFF, 0x00, 0x00,
0x08, 0x08, 0x6B, 0x6B, 0x08,
0x36, 0x12, 0x36, 0x24, 0x36,
0x06, 0x0F, 0x09, 0x0F, 0x06,
0x00, 0x00, 0x18, 0x18, 0x00,
0x00, 0x00, 0x10, 0x10, 0x00,
0x30, 0x40, 0xFF, 0x01, 0x01,
0x00, 0x1F, 0x01, 0x01, 0x1E,
0x00, 0x19, 0x1D, 0x17, 0x12,
0x00, 0x3C, 0x3C, 0x3C, 0x3C,
0x00, 0x00, 0x00, 0x00, 0x00
};

void ssd1306_get_glyph(uint8_t ch, char *glyph){
	for(int c = 0; c < 5; c++){
		*(glyph++) = pgm_read_byte(&(font[5 * ch + c]));
	}
}
